//require('../src/maps.js');
// Generated by CoffeeScript 1.12.7
(function () {
    var blue, bluebrown, chooseNumber, chooseOne, darkness, fadered, genBox, genCTF, genClouds, genDebree, genDodads,
        genFFA, genRocks, genSurvival, genSymetrical, genTTT, grayblue, greenbrown, greenpurple, lemondarkred, main,
        moonyellow, orange, pinkpurple, randomVector, redgreen, space, tanslate, tealorange, tealwhite, whitepurple,
        yellowcyan, yellowpuce;

    window.mapping = {};

    chooseNumber = function (n) {
        var i, j;
        i = Math.floor(mr.random() * n) + 1;
        j = i.toString();
        if (j.length === 1) {
            return "0" + j;
        }
        return j;
    };

    chooseOne = function (l) {
        return l[Math.floor(mr.random() * l.length)];
    };

    randomVector = function (v) {
        v[0] = mr.random() - .5;
        v[1] = mr.random() - .5;
        return v2.norm(v);
    };

    main = {
        rockColor: [63, 85, 96, 255],
        spotColor: [115, 193, 226, 255],
        fillColor: [123, 63, 68, 255]
    };

    grayblue = {
        rockColor: [127, 140, 141, 255],
        spotColor: [189, 195, 199, 255],
        fillColor: [44, 62, 80, 255]
    };

    orange = {
        rockColor: [219, 136, 79, 255],
        spotColor: [243, 156, 18, 255],
        fillColor: [192, 70, 53, 255]
    };

    blue = {
        rockColor: [211, 241, 240, 255],
        spotColor: [24, 203, 193, 255],
        fillColor: [28, 107, 132, 255]
    };

    fadered = {
        rockColor: [34, 32, 86, 255],
        spotColor: [255, 187, 132, 255],
        fillColor: [240, 88, 82, 255]
    };

    tealwhite = {
        rockColor: [209, 202, 185, 255],
        spotColor: [159, 200, 170, 255],
        fillColor: [85, 134, 120, 255]
    };

    whitepurple = {
        rockColor: [23, 41, 117, 255],
        spotColor: [188, 210, 219, 255],
        fillColor: [106, 86, 133, 255]
    };

    darkness = {
        rockColor: [27, 36, 40, 255],
        spotColor: [202, 222, 232, 255],
        fillColor: [48, 62, 75, 255]
    };

    moonyellow = {
        rockColor: [171, 164, 136, 255],
        spotColor: [228, 211, 159, 255],
        fillColor: [55, 81, 92, 255]
    };

    pinkpurple = {
        rockColor: [181, 154, 146, 255],
        spotColor: [220, 171, 169, 255],
        fillColor: [90, 54, 99, 255]
    };

    greenbrown = {
        rockColor: [50, 36, 40, 255],
        spotColor: [178, 188, 170, 255],
        fillColor: [100, 64, 62, 255]
    };

    bluebrown = {
        rockColor: [123, 109, 141, 255],
        spotColor: [132, 153, 177, 255],
        fillColor: [73, 59, 42, 255]
    };

    tealorange = {
        rockColor: [255, 74, 0, 255],
        spotColor: [68, 206, 197, 255],
        fillColor: [200, 52, 0, 255]
    };

    greenpurple = {
        rockColor: [77, 83, 130, 255],
        spotColor: [140, 186, 128, 255],
        fillColor: [81, 70, 99, 255]
    };

    lemondarkred = {
        rockColor: [193, 188, 106, 255],
        spotColor: [240, 230, 145, 255],
        fillColor: [120, 25, 25, 255]
    };

    tanslate = {
        rockColor: [61, 44, 46, 255],
        spotColor: [173, 144, 136, 255],
        fillColor: [66, 76, 85, 255]
    };

    redgreen = {
        rockColor: [115, 226, 167, 255],
        spotColor: [110, 190, 155, 255],
        fillColor: [170, 130, 150, 255]
    };

    yellowpuce = {
        rockColor: [230, 175, 46, 255],
        spotColor: [230, 213, 99, 255],
        fillColor: [99, 43, 48, 255]
    };

    yellowcyan = {
        rockColor: [228, 207, 116, 255],
        spotColor: [185, 175, 95, 255],
        fillColor: [60, 133, 111, 255]
    };

    space = {
        rockColor: [200, 255, 200, 255],
        spotColor: [0, 0, 0, 255],
        fillColor: [0, 0, 50, 255]
    };

    mapping.themes = [main, main, grayblue, blue, fadered, tealwhite, whitepurple, darkness, moonyellow, pinkpurple, greenbrown, bluebrown, greenpurple, lemondarkred, tanslate, yellowpuce, space, space, space, space, space, space, space];

    mapping.generate = function (seed) {
        var fns, r;
        window.mr = new MTwist(seed);
        sim.things = {};

        /*
    if mr.random() < .1
        sim.theme = chooseOne(mapping.themes)
    else
        a = mr.random()
        spotColor = colors.hsl2rgb([a, .5, .7, 255])
        fillColor = colors.hsl2rgb([a+mr.random()*.8-.4, .3, .2, 255])
        sim.theme =
            rockColor: spotColor
            spotColor: spotColor
            fillColor: fillColor
     */
        sim.theme = chooseOne(mapping.themes);
        switch (sim.serverType) {
            case "Survival":
                genSurvival();
                break;
            case "FFA":
                genFFA();
                break;
            case "CTF":
                genCTF();
                break;
            case "TicTacToe":
                genTTT();
                break;
            default:
                genSymetrical();
        }
        if (sim.makeRocks) {
            fns = shuffle([genClouds, genDebree, genRocks, genDodads]);
            r = mr.random();
            if (r < .2) {
                fns.pop()();
                fns.pop()();
                return fns.pop()();
            } else if (r < .5) {
                fns.pop()();
                return fns.pop()();
            } else if (r < .9) {
                return fns.pop()();
            } else {
                return "nothing";
            }
        }
    };

    mapping.generateWeaponTest = function () {
        var a, genRing, mainSpawn;
        sim.things = {};
        sim.theme = main;
        mainSpawn = a = new types.SpawnPoint();
        a.side = "alpha";
        a.spawn = "alpha";
        a.pos[0] = 0;
        a.pos[1] = 0;
        sim.things[a.id] = a;
        genRing = (function (_this) {
            return function (pos, radius, n, spec) {
                var i, m, ref, results, u, z;
                z = -mr.random() * 6 - 3;
                results = [];
                for (i = m = 0, ref = n; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
                    u = new types.Unit(spec);
                    u.pos = v2.create(pos);
                    u.pos[0] += Math.sin(i / n * 2 * Math.PI) * radius * .8;
                    u.pos[1] += Math.cos(i / n * 2 * Math.PI) * radius * .8;
                    u.side = "beta";
                    u.rot = v2.angle(u.pos) + Math.PI;
                    results.push(sim.things[u.id] = u);
                }
                return results;
            };
        })(this);
        genRing([0, 0], 1200, 12, 'ExULFRUIERUIExcIExMI');
        genRing([0, 0], 1500, 32, 'ExULFRUIERUIExcIExMI');
        return genRing([0, 0], 1800, 64, 'ExULFRUIERUIExcIExMI');
    };

    mapping.genTower = function () {
        var _, blocks, forts, i, ref, results, spec, thing, towers, u;
        blocks = ['ExULFRUIERUIExcIExMI', 'FBQUExgHGBUJFRAHEBMJEBUJFRgHExAHGBMJ'];
        towers = ['ERQQFxQQEREIFxEIFBcJFBEJERcKFxcKFBQBFBQw', 'FBQDERQQFxQQEREIFxEIFBcJFBEJERcKFxcKFBQy', 'ERQQFBcJFxQQEREIFxEIFBQDERcKFxcKFBESFBQ4', 'ERQQFBcJFxQQEREIFxEIFBQDERcKFxcKFBESFBQ1'];
        forts = ['FBQDGRcKEBQPDxcKDxEIGBQPGREIEhcJEhEJFhcJFhEJFBQ3', 'GREIFBQDEBQPDxcKDxEIGBQPGRcKEhcJEhEJFhcJFhEJFBQz', 'DRAHDRgHGBQ9EBQ/FBgDEBgPGBgPFBEJFBQDGBADFA8JEBADDRQHGxgHGxQHGxAHEBsJGBsJEA0JGA0JEBAvGBAvFBgwFBQ0', 'FAwGGBAPEBQGGBQGHBQGDBQGCBQDFBQDFCADFAgDEBAPEBgPGBgPFBgGFBAGFBwGIBQDBBQBFCQDJBQDFAQBBBQvFCQvJBQvFAQvCBQ0IBQ0FBQ0FAg0FCA0'];
        ref = sim.things;
        results = [];
        for (_ in ref) {
            thing = ref[_];
            if (thing.commandPoint) {
                spec = chooseOne(towers);
            } else {
                continue;
            }
            u = new types.Unit(spec);
            u.pos = v2.create(thing.pos);
            u.side = thing.side;
            u.rot = v2.angle(u.pos) + Math.PI;
            sim.things[u.id] = u;
            results.push((function () {
                var m, results1;
                results1 = [];
                for (i = m = 0; m < 6; i = ++m) {
                    if (thing.commandPoint) {
                        spec = blocks[0];
                    } else {
                        continue;
                    }
                    u = new types.Unit(spec);
                    u.pos = v2.create(thing.pos);
                    u.pos[0] += Math.sin(i / 3 * Math.PI) * thing.radius * .8;
                    u.pos[1] += Math.cos(i / 3 * Math.PI) * thing.radius * .8;
                    u.side = thing.side;
                    u.rot = Math.PI / 2;
                    results1.push(sim.things[u.id] = u);
                }
                return results1;
            })());
        }
        return results;
    };

    genFFA = function () {
        var _, a, i, len, m, o, p, pos, q, r, ref, ref1, ref2, results, s, t, tooClose, w;
        for (i = m = 0; m < 4; i = ++m) {
            s = new types.SpawnPoint();
            s.side = "alpha";
            s.spawn = "alpha";
            if (i === 0) {
                s.pos[0] = -sim.mapScale * 3000;
                s.pos[1] = mr.random() * 3000 - 1500;
            } else if (i === 1) {
                s.pos[0] = sim.mapScale * 3000;
                s.pos[1] = mr.random() * 3000 - 1500;
            } else if (i === 2) {
                s.pos[0] = mr.random() * 3000 - 1500;
                s.pos[1] = -sim.mapScale * 3000;
            } else if (i === 3) {
                s.pos[0] = mr.random() * 3000 - 1500;
                s.pos[1] = sim.mapScale * 3000;
            }
            sim.things[s.id] = s;
        }
        pos = [];
        for (i = o = 0, ref = sim.numComPoints; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
            a = new types.CommandPoint();
            a.value = Math.random() * .8 + .2;
            a.size = [a.value, a.value];
            a.radius *= a.value;
            a.side = "neutral";
            a.z = -.01;
            for (i = q = 0; q < 10; i = ++q) {
                tooClose = false;
                randomVector(a.pos);
                v2.scale(a.pos, (300 + mr.random() * 2000) * sim.mapScale);
                ref1 = sim.things;
                for (_ in ref1) {
                    t = ref1[_];
                    if (v2.distance(t.pos, a.pos) < (t.radius + a.radius + 100)) {
                        tooClose = true;
                        break;
                    }
                }
                if (!tooClose) {
                    break;
                }
            }
            sim.things[a.id] = a;
        }
        ref2 = sim.players;
        results = [];
        for (w = 0, len = ref2.length; w < len; w++) {
            p = ref2[w];
            r = new types.Rock();
            r.image = "parts/fireFlackExp1.png";
            r.z = -0.1;
            r["static"] = false;
            r.player = p;
            r.tick = function () {
                var found, ref3;
                found = false;
                ref3 = sim.things;
                for (_ in ref3) {
                    t = ref3[_];
                    if (t.unit && t.owner === this.player.number) {
                        this.pos = t.pos;
                        this.vel = t.vel;
                        this.size = [t.radius / 30, t.radius / 30];
                        found = true;
                        break;
                    }
                }
                if (found) {
                    return this.color = [245, 171, 53, this.player.money / sim.victoryGoal * 255];
                } else {
                    return this.color = [0, 0, 0, 0];
                }
            };
            r.move = function () {
                return this.rot += .08;
            };
            results.push(sim.things[r.id] = r);
        }
        return results;
    };

    genSymetrical = function () {
        var _, a, b, from_center, i, m, mainSpawn, o, pos, ref, ref1, results, t, tooClose;
        mainSpawn = a = new types.SpawnPoint();
        a.side = "alpha";
        a.spawn = "alpha";
        a.pos[0] = -sim.mapScale * 3000;
        a.pos[1] = mr.random() * 3000 - 1500;
        sim.things[a.id] = a;
        b = new types.SpawnPoint();
        b.side = "beta";
        b.spawn = "beta";
        b.pos[0] = sim.mapScale * 3000;
        b.pos[1] = -a.pos[1];
        sim.things[b.id] = b;
        pos = [];
        results = [];
        for (i = m = 0, ref = sim.numComPoints / 2; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
            a = new types.CommandPoint();
            a.z = -.01;
            if (i === 0) {
                v2.set(mainSpawn.pos, a.pos);
                from_center = v2.mag(a.pos);
                v2.scale(a.pos, (from_center - 1500) / from_center);
            } else {
                for (i = o = 0; o < 10; i = ++o) {
                    tooClose = false;
                    randomVector(a.pos);
                    v2.scale(a.pos, (300 + mr.random() * 2000) * sim.mapScale);
                    ref1 = sim.things;
                    for (_ in ref1) {
                        t = ref1[_];
                        if (v2.distance(t.pos, a.pos) < (t.radius + a.radius + 100)) {
                            tooClose = true;
                            break;
                        }
                    }
                    if (!tooClose) {
                        break;
                    }
                }
            }
            sim.things[a.id] = a;
            b = new types.CommandPoint();
            b.z = -.01;
            b.pos[0] = -a.pos[0];
            b.pos[1] = -a.pos[1];
            a.side = "alpha";
            b.side = "beta";
            results.push(sim.things[b.id] = b);
        }
        return results;
    };

    genSurvival = function () {
        var cp, i, m, ref, results, spawn, th;
        spawn = new types.SpawnPoint();
        spawn.side = "alpha";
        spawn.spawn = "alpha";
        spawn.pos = v2.create([0, 0]);
        sim.things[spawn.id] = spawn;
        cp = function (r, th, side) {
            var point;
            point = new types.CommandPoint();
            point.z = -.01;
            point.pos[0] = Math.cos(th) * r * sim.mapScale;
            point.pos[1] = Math.sin(th) * r * sim.mapScale;
            point.side = side;
            return sim.things[point.id] = point;
        };
        results = [];
        for (i = m = 0, ref = sim.numComPoints; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
            th = i * Math.PI * 2 / sim.numComPoints;
            if (i % 2 === 0) {
                results.push(cp(1320, th, "beta"));
            } else {
                results.push(cp(960, th, "alpha"));
            }
        }
        return results;
    };

    genCTF = function () {
        var _, a, alphaSpawn, b, betaSpawn, createFlag, flag, from_center, homePoints, i, len, m, o, point, pos, q, ref,
            ref1, ref2, results, t, tooClose;
        createFlag = function () {
            var flag;
            flag = new types.Rock();
            flag.flag = true;
            flag["static"] = false;
            flag.z = 2;
            flag.torq = Math.random() * .2;
            flag.image = types.Flag.prototype.image;
            flag.color = types.Flag.prototype.color;
            flag.size = types.Flag.prototype.size;
            flag.tick = function () {
                var closest, eHome, eHomeDist, enemySpawn, home, homeDist, minDist, ref, ref1, ref2, ref3, spawn;
                closest = function (pos, fn, maxDist) {
                    var _, dist, minDist, minT, ref, t;
                    if (maxDist == null) {
                        maxDist = 10000000;
                    }
                    minDist = 0;
                    minT = null;
                    ref = sim.things;
                    for (_ in ref) {
                        t = ref[_];
                        if (fn(t)) {
                            dist = v2.distance(pos, t.pos);
                            if (dist > maxDist) {
                                continue;
                            }
                            if (dist < minDist || minT === null) {
                                minDist = dist;
                                minT = t;
                            }
                        }
                    }
                    return minT;
                };
                spawn = sim.findSpawnPoint(this.side);
                enemySpawn = sim.findSpawnPoint(otherSide(this.side));
                if (!spawn || !enemySpawn) {
                    return;
                }
                home = closest(spawn.pos, function (t) {
                    return t.commandPoint;
                }) || spawn;
                eHome = closest(enemySpawn.pos, function (t) {
                    return t.commandPoint;
                }) || enemySpawn;
                homeDist = v2.distance(this.pos, home.pos);
                eHomeDist = v2.distance(this.pos, eHome.pos);
                if (homeDist < home.radius) {
                    this.home = true;
                    if (this.side === ((ref = this.target) != null ? ref.side : void 0)) {
                        this.target.carryFlag = false;
                        this.target = null;
                    }
                } else {
                    this.home = false;
                    if (eHomeDist < eHome.radius) {
                        this.side = otherSide(this.side);
                        if (this.target) {
                            this.target.carryFlag = false;
                            if ((ref1 = sim.players[this.target.owner]) != null) {
                                ref1.capps += 1;
                            }
                            this.target = null;
                        }
                    }
                }
                if (!this.target || v2.distance(this.pos, this.target.pos) > types.Flag.prototype.range || this.target.dead) {
                    if ((ref2 = this.target) != null) {
                        ref2.carryFlag = false;
                    }
                    closest = null;
                    minDist = 2e308;
                    if (homeDist > home.radius) {
                        sim.unitSpaces[this.side].findInRange(this.pos, types.Flag.prototype.range, (function (_this) {
                            return function (u) {
                                var dist;
                                if (u.carryFlag) {
                                    return false;
                                }
                                dist = v2.distanceSq(_this.pos, u.pos) < minDist;
                                if (dist < minDist) {
                                    closest = u;
                                    minDist - dist;
                                }
                                return false;
                            };
                        })(this));
                    }
                    if (eHomeDist > eHome.radius) {
                        sim.unitSpaces[otherSide(this.side)].findInRange(this.pos, types.Flag.prototype.range, (function (_this) {
                            return function (u) {
                                var dist;
                                if (u.carryFlag) {
                                    return false;
                                }
                                dist = v2.distanceSq(_this.pos, u.pos) < minDist;
                                if (dist < minDist) {
                                    closest = u;
                                    minDist - dist;
                                }
                                return false;
                            };
                        })(this));
                    }
                    this.target = closest;
                    if ((ref3 = this.target) != null) {
                        ref3.carryFlag = true;
                    }
                }
                if (this.target) {
                    this.target.cloak = 0;
                    this.target.jump = 0;
                    return v2.scale(this.target.vel, types.Flag.prototype.slow);
                }
            };
            flag.move = function () {
                var s;
                if (this.target) {
                    v2.scale(v2.norm(v2.sub(this.target.pos, this.pos, this.vel)), v2.distance(this.pos, this.target.pos) / (types.Flag.prototype.range - 10) * this.target.maxSpeed);
                } else {
                    v2.scale(this.vel, types.Flag.prototype.stopFriction);
                }
                v2.add(this.pos, this.vel);
                this.rot += this.torq;
                s = 20000;
                if (this.pos[0] > s) {
                    this.pos[0] = s;
                }
                if (this.pos[0] < -s) {
                    this.pos[0] = -s;
                }
                if (this.pos[1] > s) {
                    this.pos[1] = s;
                }
                if (this.pos[1] < -s) {
                    return this.pos[1] = -s;
                }
            };
            return sim.things[flag.id] = flag;
        };
        alphaSpawn = a = new types.SpawnPoint();
        a.side = "alpha";
        a.spawn = "alpha";
        a.pos[0] = -sim.mapScale * 3000;
        a.pos[1] = mr.random() * 3000 - 1500;
        sim.things[a.id] = a;
        betaSpawn = b = new types.SpawnPoint();
        b.side = "beta";
        b.spawn = "beta";
        b.pos[0] = sim.mapScale * 3000;
        b.pos[1] = -a.pos[1];
        sim.things[b.id] = b;
        pos = [];
        homePoints = [];
        for (i = m = 0, ref = sim.numComPoints / 2; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
            a = new types.CommandPoint();
            a.z = -.01;
            if (i === 0) {
                v2.set(alphaSpawn.pos, a.pos);
                from_center = v2.mag(a.pos);
                v2.scale(a.pos, (from_center - 1500) / from_center);
            } else {
                for (i = o = 0; o < 10; i = ++o) {
                    tooClose = false;
                    randomVector(a.pos);
                    v2.scale(a.pos, (300 + mr.random() * 2000) * sim.mapScale);
                    ref1 = sim.things;
                    for (_ in ref1) {
                        t = ref1[_];
                        if (v2.distance(t.pos, a.pos) < (t.radius + a.radius + 100)) {
                            tooClose = true;
                            break;
                        }
                    }
                    if (!tooClose) {
                        break;
                    }
                }
            }
            sim.things[a.id] = a;
            b = new types.CommandPoint();
            b.z = -.01;
            b.pos[0] = -a.pos[0];
            b.pos[1] = -a.pos[1];
            a.side = "alpha";
            b.side = "beta";
            sim.things[b.id] = b;
            if (i === 0) {
                homePoints = [a, b];
            }
        }
        a = homePoints[0] || alphaSpawn;
        b = homePoints[1] || betaSpawn;
        ref2 = [a, b];
        results = [];
        for (q = 0, len = ref2.length; q < len; q++) {
            point = ref2[q];
            results.push((function () {
                var ref3, results1, w;
                results1 = [];
                for (i = w = 0, ref3 = sim.numFlags; 0 <= ref3 ? w < ref3 : w > ref3; i = 0 <= ref3 ? ++w : --w) {
                    flag = createFlag();
                    flag.side = point.side;
                    results1.push(v2.add(v2.scale(v2.random(flag.pos), Math.random() * point.radius), point.pos));
                }
                return results1;
            })());
        }
        return results;
    };

    genTTT = function () {
        var alpha, beta, i, m, mu, o, q, results, u, x, y;
        for (x = m = -1; m <= 1; x = ++m) {
            for (y = o = -1; o <= 1; y = ++o) {
                u = new types.Unit('{"parts":[{"pos":[120,120],"type":"HArmor2x2","dir":0},{"pos":[-120,120],"type":"HArmor2x2","dir":0},{"pos":[-160,80],"type":"HArmor2x2","dir":0},{"pos":[-40,120],"type":"HArmor2x2","dir":0},{"pos":[-80,120],"type":"HArmor2x2","dir":0},{"pos":[0,120],"type":"HArmor2x2","dir":0},{"pos":[80,120],"type":"HArmor2x2","dir":0},{"pos":[-160,40],"type":"HArmor2x2","dir":0},{"pos":[-160,0],"type":"HArmor2x2","dir":0},{"pos":[160,0],"type":"HArmor2x2","dir":0},{"pos":[40,120],"type":"HArmor2x2","dir":0},{"pos":[0,40],"type":"HArmor2x2","dir":0},{"pos":[80,-40],"type":"HArmor2x2","dir":0},{"pos":[80,0],"type":"HArmor2x2","dir":0},{"pos":[-80,-40],"type":"HArmor2x2","dir":0},{"pos":[-80,0],"type":"HArmor2x2","dir":0},{"pos":[-80,40],"type":"HArmor2x2","dir":0},{"pos":[80,40],"type":"HArmor2x2","dir":0},{"pos":[-40,80],"type":"HArmor2x2","dir":0},{"pos":[120,-160],"type":"HArmor2x2","dir":0},{"pos":[0,80],"type":"HArmor2x2","dir":0},{"pos":[0,-80],"type":"HArmor2x2","dir":0},{"pos":[-40,-80],"type":"HArmor2x2","dir":0},{"pos":[40,-80],"type":"HArmor2x2","dir":0},{"pos":[-120,-80],"type":"HArmor2x2","dir":0},{"pos":[-80,-120],"type":"HArmor2x2","dir":0},{"pos":[120,-80],"type":"HArmor2x2","dir":0},{"pos":[-40,-120],"type":"HArmor2x2","dir":0},{"pos":[80,-120],"type":"HArmor2x2","dir":0},{"pos":[120,-40],"type":"HArmor2x2","dir":0},{"pos":[40,-120],"type":"HArmor2x2","dir":0},{"pos":[-120,0],"type":"HArmor2x2","dir":0},{"pos":[-120,-40],"type":"HArmor2x2","dir":0},{"pos":[0,-120],"type":"HArmor2x2","dir":0},{"pos":[120,0],"type":"HArmor2x2","dir":0},{"pos":[120,40],"type":"HArmor2x2","dir":0},{"pos":[-120,40],"type":"HArmor2x2","dir":0},{"pos":[-120,80],"type":"HArmor2x2","dir":0},{"pos":[120,80],"type":"HArmor2x2","dir":0},{"pos":[-40,0],"type":"HArmor2x2","dir":0},{"pos":[40,0],"type":"HArmor2x2","dir":0},{"pos":[-80,80],"type":"HArmor2x2","dir":0},{"pos":[80,80],"type":"HArmor2x2","dir":0},{"pos":[-40,40],"type":"HArmor2x2","dir":0},{"pos":[40,40],"type":"HArmor2x2","dir":0},{"pos":[-40,-40],"type":"HArmor2x2","dir":0},{"pos":[-120,-120],"type":"HArmor2x2","dir":0},{"pos":[120,-120],"type":"HArmor2x2","dir":0},{"pos":[-80,-80],"type":"HArmor2x2","dir":0},{"pos":[80,-80],"type":"HArmor2x2","dir":0},{"pos":[40,-40],"type":"HArmor2x2","dir":0},{"pos":[160,80],"type":"HArmor2x2","dir":0},{"pos":[0,0],"type":"HArmor2x2","dir":0},{"pos":[160,40],"type":"HArmor2x2","dir":0},{"pos":[0,-40],"type":"HArmor2x2","dir":0},{"pos":[-160,-40],"type":"HArmor2x2","dir":0},{"pos":[160,-40],"type":"HArmor2x2","dir":0},{"pos":[-160,-160],"type":"HArmor2x2","dir":0},{"pos":[-120,-160],"type":"HArmor2x2","dir":0},{"pos":[-160,-120],"type":"HArmor2x2","dir":0},{"pos":[160,-120],"type":"HArmor2x2","dir":0},{"pos":[160,-160],"type":"HArmor2x2","dir":0},{"pos":[40,80],"type":"HArmor2x2","dir":0},{"pos":[80,-160],"type":"HArmor2x2","dir":0},{"pos":[-80,-160],"type":"HArmor2x2","dir":0},{"pos":[-120,160],"type":"HArmor2x2","dir":0},{"pos":[160,160],"type":"HArmor2x2","dir":0},{"pos":[-40,-160],"type":"HArmor2x2","dir":0},{"pos":[40,-160],"type":"HArmor2x2","dir":0},{"pos":[0,-160],"type":"HArmor2x2","dir":0},{"pos":[-160,160],"type":"HArmor2x2","dir":0},{"pos":[-80,160],"type":"HArmor2x2","dir":0},{"pos":[80,160],"type":"HArmor2x2","dir":0},{"pos":[120,160],"type":"HArmor2x2","dir":0},{"pos":[40,160],"type":"HArmor2x2","dir":0},{"pos":[-160,120],"type":"HArmor2x2","dir":0},{"pos":[0,160],"type":"HArmor2x2","dir":0},{"pos":[-40,160],"type":"HArmor2x2","dir":0},{"pos":[160,120],"type":"HArmor2x2","dir":0},{"pos":[-160,-80],"type":"HArmor2x2","dir":0},{"pos":[160,-80],"type":"HArmor2x2","dir":0},{"pos":[-140,140],"type":"Stripe2x2Corner","dir":0},{"pos":[170,-170],"type":"Stripe1x1Corner","dir":3},{"pos":[-170,-150],"type":"Stripe1x1","dir":0},{"pos":[170,80],"type":"Stripe1x2","dir":0},{"pos":[-170,40],"type":"Stripe1x2","dir":0},{"pos":[170,40],"type":"Stripe1x2","dir":0},{"pos":[-170,80],"type":"Stripe1x2","dir":0},{"pos":[-170,170],"type":"Stripe1x1Corner","dir":0},{"pos":[170,0],"type":"Stripe1x2","dir":0},{"pos":[100,-140],"type":"Stripe2x2","dir":3},{"pos":[80,-170],"type":"Stripe1x2","dir":3},{"pos":[20,-140],"type":"Stripe2x2","dir":3},{"pos":[-170,0],"type":"Stripe1x2","dir":0},{"pos":[-170,-120],"type":"Stripe1x2","dir":0},{"pos":[170,-120],"type":"Stripe1x2","dir":0},{"pos":[-170,-40],"type":"Stripe1x2","dir":0},{"pos":[-170,120],"type":"Stripe1x2","dir":0},{"pos":[170,170],"type":"Stripe1x1Corner","dir":0},{"pos":[-120,170],"type":"Stripe1x2","dir":3},{"pos":[150,170],"type":"Stripe1x1","dir":1},{"pos":[-150,170],"type":"Stripe1x1","dir":3},{"pos":[-170,-170],"type":"Stripe1x1Corner","dir":1},{"pos":[-80,170],"type":"Stripe1x2","dir":3},{"pos":[80,170],"type":"Stripe1x2","dir":1},{"pos":[-40,170],"type":"Stripe1x2","dir":3},{"pos":[40,170],"type":"Stripe1x2","dir":1},{"pos":[0,170],"type":"Stripe1x2","dir":1},{"pos":[-150,-170],"type":"Stripe1x1","dir":1},{"pos":[150,-170],"type":"Stripe1x1","dir":3},{"pos":[-120,-170],"type":"Stripe1x2","dir":1},{"pos":[120,-170],"type":"Stripe1x2","dir":3},{"pos":[0,-170],"type":"Stripe1x2","dir":3},{"pos":[170,-80],"type":"Stripe1x2","dir":0},{"pos":[120,170],"type":"Stripe1x2","dir":1},{"pos":[170,120],"type":"Stripe1x2","dir":0},{"pos":[-170,-80],"type":"Stripe1x2","dir":0},{"pos":[170,-150],"type":"Stripe1x1","dir":0},{"pos":[40,-170],"type":"Stripe1x2","dir":3},{"pos":[170,150],"type":"Stripe1x1","dir":0},{"pos":[-100,-100],"type":"Stripe2x2Corner","dir":1},{"pos":[100,-100],"type":"Stripe2x2Corner","dir":3},{"pos":[-140,-140],"type":"Stripe2x2Corner","dir":1},{"pos":[140,-140],"type":"Stripe2x2Corner","dir":3},{"pos":[60,-60],"type":"Stripe2x2Corner","dir":3},{"pos":[140,140],"type":"Stripe2x2Corner","dir":0},{"pos":[-100,100],"type":"Stripe2x2Corner","dir":0},{"pos":[100,100],"type":"Stripe2x2Corner","dir":0},{"pos":[-60,60],"type":"Stripe2x2Corner","dir":0},{"pos":[60,60],"type":"Stripe2x2Corner","dir":0},{"pos":[-140,100],"type":"Stripe2x2","dir":0},{"pos":[140,100],"type":"Stripe2x2","dir":0},{"pos":[-140,60],"type":"Stripe2x2","dir":0},{"pos":[140,60],"type":"Stripe2x2","dir":0},{"pos":[-140,20],"type":"Stripe2x2","dir":0},{"pos":[140,20],"type":"Stripe2x2","dir":0},{"pos":[-140,-20],"type":"Stripe2x2","dir":0},{"pos":[140,-20],"type":"Stripe2x2","dir":0},{"pos":[-140,-60],"type":"Stripe2x2","dir":0},{"pos":[140,-60],"type":"Stripe2x2","dir":0},{"pos":[-140,-100],"type":"Stripe2x2","dir":0},{"pos":[140,-100],"type":"Stripe2x2","dir":0},{"pos":[-100,-60],"type":"Stripe2x2","dir":0},{"pos":[100,-60],"type":"Stripe2x2","dir":0},{"pos":[-100,-20],"type":"Stripe2x2","dir":0},{"pos":[100,-20],"type":"Stripe2x2","dir":0},{"pos":[-100,20],"type":"Stripe2x2","dir":0},{"pos":[100,20],"type":"Stripe2x2","dir":0},{"pos":[-40,-170],"type":"Stripe1x2","dir":1},{"pos":[-100,60],"type":"Stripe2x2","dir":0},{"pos":[100,60],"type":"Stripe2x2","dir":0},{"pos":[-60,20],"type":"Stripe2x2","dir":0},{"pos":[60,20],"type":"Stripe2x2","dir":0},{"pos":[-60,-20],"type":"Stripe2x2","dir":0},{"pos":[60,-20],"type":"Stripe2x2","dir":0},{"pos":[-20,-60],"type":"Stripe2x2","dir":1},{"pos":[20,-60],"type":"Stripe2x2","dir":3},{"pos":[20,20],"type":"Stripe2x2Corner","dir":0},{"pos":[-20,20],"type":"Stripe2x2Corner","dir":0},{"pos":[20,-20],"type":"Stripe2x2Corner","dir":3},{"pos":[-20,-20],"type":"Stripe2x2Corner","dir":1},{"pos":[-20,60],"type":"Stripe2x2","dir":1},{"pos":[20,60],"type":"Stripe2x2","dir":3},{"pos":[-60,100],"type":"Stripe2x2","dir":1},{"pos":[60,100],"type":"Stripe2x2","dir":3},{"pos":[-60,-60],"type":"Stripe2x2Corner","dir":1},{"pos":[-170,150],"type":"Stripe1x1","dir":0},{"pos":[-20,100],"type":"Stripe2x2","dir":1},{"pos":[20,100],"type":"Stripe2x2","dir":3},{"pos":[-100,140],"type":"Stripe2x2","dir":1},{"pos":[100,140],"type":"Stripe2x2","dir":3},{"pos":[-60,140],"type":"Stripe2x2","dir":1},{"pos":[60,140],"type":"Stripe2x2","dir":3},{"pos":[-20,140],"type":"Stripe2x2","dir":1},{"pos":[20,140],"type":"Stripe2x2","dir":3},{"pos":[-60,-100],"type":"Stripe2x2","dir":1},{"pos":[60,-100],"type":"Stripe2x2","dir":3},{"pos":[-20,-100],"type":"Stripe2x2","dir":1},{"pos":[20,-100],"type":"Stripe2x2","dir":3},{"pos":[-100,-140],"type":"Stripe2x2","dir":1},{"pos":[-80,-170],"type":"Stripe1x2","dir":1},{"pos":[-60,-140],"type":"Stripe2x2","dir":1},{"pos":[60,-140],"type":"Stripe2x2","dir":3},{"pos":[-20,-140],"type":"Stripe2x2","dir":1},{"pos":[170,-40],"type":"Stripe1x2","dir":0}],"name":"","aiRules":[]}');
                u.side = "neutral";
                u.grid = [x, y];
                u.pos = [2 * x * u.radius, 2 * y * u.radius];
                u.ttt = "_";
                u.warpIn = 1;
                u.tick = function () {
                    switch (this.ttt) {
                        case "alpha":
                            return this.color = [0, 0, 255, 255];
                        case "beta":
                            return this.color = [255, 255, 0, 255];
                        default:
                            return this.color = [0, 0, 0, 255];
                    }
                };
                sim.things[u.id] = u;
            }
        }
        alpha = "ALPHA";
        beta = "BETA";
        results = [];
        for (i = q = 0; q < 5; i = ++q) {
            mu = new types.Rock;
            mu.z = 10;
            mu["static"] = false;
            mu.size = [5, 5];
            mu.vel = [-350, 0];
            mu.pos = [(i - alpha.length / 2) * 180, 1000];
            mu.char = {
                alpha: alpha[i],
                beta: beta[i]
            };
            mu.tick = function () {
                var char;
                char = this.char[sim.turn];
                if (char) {
                    this.image = "parts/decals/letter" + char + ".png";
                    return this.color = (function () {
                        switch (sim.turn) {
                            case "alpha":
                                return [0, 0, 255, 255];
                            case "beta":
                                return [255, 255, 0, 255];
                            default:
                                return [0, 0, 0, 255];
                        }
                    })();
                } else {
                    return this.color = [0, 0, 0, 0];
                }
            };
            results.push(sim.things[mu.id] = mu);
        }
        return results;
    };

    genClouds = function () {
        var alpha, c, cloud, clouds, i, len, m, n, o, otherCloud, overlaps, ref, results, s, type;
        if (mr.random() < .3) {
            c = 0;
        } else {
            c = 255;
        }
        alpha = 15 + 20 * mr.random();
        type = chooseOne(["s", "v", "a", "g"]);
        n = Math.PI * sim.mapScale * sim.mapScale * 8;
        clouds = [];
        results = [];
        for (i = m = 0, ref = n * mr.random(); 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
            cloud = new types.Rock();
            cloud.image = "img/debree/" + type + "cloud" + (chooseNumber(4)) + ".png";
            randomVector(cloud.pos);
            v2.scale(cloud.pos, (mr.random() * 3200) * sim.mapScale);
            overlaps = 0;
            for (o = 0, len = clouds.length; o < len; o++) {
                otherCloud = clouds[o];
                if (v2.distance(cloud.pos, otherCloud.pos) < 1200) {
                    overlaps += 1;
                }
            }
            if (overlaps > 2) {
                continue;
            }
            cloud.color = v4.create(sim.theme.rockColor);

            /*
      cloud.color[0] = c
      cloud.color[1] = c
      cloud.color[2] = c
       */
            cloud.color[3] = alpha;
            s = 4 + mr.random() * 4;
            cloud.size = [s, s];
            cloud.z = (mr.random() - .5) * 200;
            cloud.rot = mr.random() * Math.PI * 2;
            if (mr.random() > .5) {
                cloud.z *= 5;
            }
            sim.things[cloud.id] = cloud;
            results.push(clouds.push(cloud));
        }
        return results;
    };

    genRocks = function () {
        var i, m, ref, results, rock;
        results = [];
        for (i = m = 0, ref = sim.numRocks; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
            rock = new types.Rock();
            rock.image = chooseOne(["img/rocks/srock01.png", "img/rocks/srock02.png", "img/rocks/srock03.png", "img/rocks/srock04.png", "img/rocks/srock05.png", "img/rocks/srock06.png", "img/rocks/srock07.png", "img/rocks/mrock01.png", "img/rocks/mrock02.png", "img/rocks/mrock03.png", "img/rocks/mrock04.png", "img/rocks/mrock05.png", "img/rocks/mrock06.png", "img/rocks/lrock01.png", "img/rocks/lrock02.png", "img/rocks/lrock03.png", "img/rocks/lrock04.png", "img/rocks/lrock05.png"]);
            randomVector(rock.pos);
            v2.scale(rock.pos, (300 + mr.random() * 3000) * sim.mapScale);
            rock.color = sim.theme.spotColor;
            rock.rot = 2 * Math.PI * mr.random();
            rock.z = (mr.random() - .5) * 200;
            if (rock.z > 0) {
                rock.z += 1;
            }
            results.push(sim.things[rock.id] = rock);
        }
        return results;
    };

    genBox = function () {
        var a, m, results, rock, x, y, z;
        results = [];
        for (x = m = -5; m <= 5; x = ++m) {
            results.push((function () {
                var o, results1;
                results1 = [];
                for (y = o = -5; o <= 5; y = ++o) {
                    results1.push((function () {
                        var q, results2;
                        results2 = [];
                        for (z = q = -5; q <= 5; z = ++q) {
                            rock = new types.Rock();
                            a = 1000;
                            rock.pos = [x * a, y * a];
                            rock.z = z * 50;
                            rock.color = [255, 255, 255, 255];
                            rock.image = "img/pip1.png";
                            results2.push(sim.things[rock.id] = rock);
                        }
                        return results2;
                    })());
                }
                return results1;
            })());
        }
        return results;
    };

    genDebree = function () {
        var c, clusterCenter, debree, debreeColor, i, m, n, ref, results;
        debreeColor = sim.theme.spotColor;
        n = Math.PI * sim.mapScale * sim.mapScale * 4;
        results = [];
        for (c = m = 0, ref = n * mr.random(); 0 <= ref ? m < ref : m > ref; c = 0 <= ref ? ++m : --m) {
            clusterCenter = v2.create();
            randomVector(clusterCenter);
            v2.scale(clusterCenter, (300 + mr.random() * 3000) * sim.mapScale);
            if (mr.random() < .7) {
                debree = new types.Rock();
                if (mr.random() > .2) {
                    debree.image = "img/debree/bigdebree" + (chooseNumber(12)) + ".png";
                } else {
                    debree.image = "img/debree/civ" + (chooseNumber(5)) + ".png";
                }
                v2.add(debree.pos, clusterCenter);
                debree.z = (mr.random() - .5) * 200;
                debree.color = debreeColor;
                debree.rot = mr.random() * 2 * Math.PI;
                sim.things[debree.id] = debree;
            }
            results.push((function () {
                var o, ref1, results1;
                results1 = [];
                for (i = o = 0, ref1 = 20 * mr.random(); 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
                    debree = new types.Rock();
                    debree.image = "img/debree/debree" + (chooseNumber(25)) + ".png";
                    randomVector(debree.pos);
                    v2.scale(debree.pos, mr.random() * 600);
                    v2.add(debree.pos, clusterCenter);
                    debree.z = (mr.random() - .5) * 200;
                    debree.color = debreeColor;
                    debree.rot = mr.random() * 2 * Math.PI;
                    results1.push(sim.things[debree.id] = debree);
                }
                return results1;
            })());
        }
        return results;
    };

    genDodads = function () {
        var _, chooseDodad, dodadColor, genRing, ref, results, single, thing;
        chooseDodad = function () {
            return chooseOne(["img/dodads/bigdodad01.png", "img/dodads/bigdodad02.png", "img/dodads/bigdodad03.png", "img/dodads/bigdodad04.png", "img/dodads/bigdodad05.png", "img/dodads/meddodad01.png", "img/dodads/meddodad02.png", "img/dodads/meddodad03.png", "img/dodads/meddodad04.png"]);
        };
        dodadColor = sim.theme.spotColor;
        genRing = (function (_this) {
            return function (pos, radius) {
                var dodad, i, image, level, m, ref, results, z;
                image = chooseDodad();
                z = -mr.random() * 6 - 3;
                results = [];
                for (level = m = 0, ref = mr.random() * 4; 0 <= ref ? m < ref : m > ref; level = 0 <= ref ? ++m : --m) {
                    results.push((function () {
                        var o, results1;
                        results1 = [];
                        for (i = o = 0; o < 6; i = ++o) {
                            dodad = new types.Rock();
                            dodad.image = image;
                            dodad.color = dodadColor;
                            dodad.pos = v2.create(pos);
                            dodad.pos[0] += Math.sin(i / 3 * Math.PI) * radius * .8;
                            dodad.pos[1] += Math.cos(i / 3 * Math.PI) * radius * .8;
                            dodad.rot = (6 - i) / 3 * Math.PI + Math.PI / 2;
                            dodad.z = z - level * 10;
                            results1.push(sim.things[dodad.id] = dodad);
                        }
                        return results1;
                    })());
                }
                return results;
            };
        })(this);
        single = (function (_this) {
            return function (pos) {
                var dodad, image;
                image = chooseDodad();
                dodad = new types.Rock();
                dodad.image = image;
                dodad.color = dodadColor;
                dodad.pos = v2.create(pos);
                dodad.rot = mr.random() * 2 * Math.PI;
                dodad.z = -2 + mr.random();
                return sim.things[dodad.id] = dodad;
            };
        })(this);
        ref = sim.things;
        results = [];
        for (_ in ref) {
            thing = ref[_];
            if (mr.random() < .5) {
                continue;
            }
            if (!(thing.spawn || thing.commandPoint)) {
                continue;
            }
            if (mr.random() < 0.5) {
                results.push(genRing(thing.pos, thing.radius * 3));
            } else {
                results.push(single(thing.pos));
            }
        }
        return results;
    };

    mapping.save = function (name) {
        var k, len, m, map, n, num, p, player, ref, ref1, ref2, spec, thing;
        p = function (pos) {
            return [Math.floor(pos[0]), Math.floor(pos[1])];
        };
        map = {};
        map.name = name;
        map.players = {};
        ref = sim.players;
        for (k in ref) {
            player = ref[k];
            map.players[player.id] = {
                name: player.name,
                buildBar: player.buildBar,
                aiRules: player.aiRules,
                color: player.color,
                side: player.side
            };
        }
        map.things = [];
        ref1 = sim.things;
        for (k in ref1) {
            thing = ref1[k];
            if (thing.unit) {
                num = -1;
                ref2 = player.buildBar;
                for (n = m = 0, len = ref2.length; m < len; n = ++m) {
                    spec = ref2[n];
                    if (simpleEquals(spec, thing.spec)) {
                        num = n;
                    }
                }
                map.things.push(["unit", p(thing.pos), thing.side, thing.owner, num, thing.rot]);
            } else if (thing.spawn) {
                map.things.push(["spawnPoint", p(thing.pos), thing.side]);
            } else if (thing.commandPoint) {
                map.things.push(["commandPoint", p(thing.pos), thing.side]);
            }
        }
        console.log(name + " =\n" + csonify(map, 1));
        localStorage["map_" + name] = JSON.stringify(map);
    };

    mapping.load = function (name) {
        var base, id, len, m, map, owner, p, player, ref, ref1, results, thing;
        map = JSON.parse(localStorage["map_" + name]);
        if (window.network != null) {
            if (typeof (base = window.network).close === "function") {
                base.close();
            }
        }
        bubbles.clear();
        window.intp = new Interpolator();
        window.sim = new Sim();
        sim.sound = true;
        sim.local = true;
        intp.local = true;
        sim.start();
        window.network = new Local();
        ui.mode = "battle";
        ref = map.players;
        for (id in ref) {
            p = ref[id];
            player = sim.playerJoin({}, id, p.name, p.color, p.buildBar, p.aiRules);
            player.side = p.side;
            player.connected = true;
            player.ready = true;
        }
        sim.things = {};
        ref1 = map.things;
        results = [];
        for (m = 0, len = ref1.length; m < len; m++) {
            p = ref1[m];
            console.log(p);
            if (p[0] === "spawnPoint") {
                thing = new types.SpawnPoint();
                thing.spawn = p[2];
            } else if (p[0] === "commandPoint") {
                thing = new types.CommandPoint();
            } else if (p[0] === "unit") {
                owner = map.players[p[3]];
                thing = new types.Unit(owner.buildBar[p[4]]);
                thing.owner = p[3];
                thing.number = p[4];
                thing.rot = p[5] || 0;
            }
            v2.set(p[1], thing.pos);
            thing.side = p[2];
            results.push(sim.things[thing.id] = thing);
        }
        return results;
    };

}).call(this);
;


