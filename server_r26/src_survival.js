//require('../src/survival.js');
// Generated by CoffeeScript 1.12.7
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  window.modes.Survival = (function(superClass) {
    extend(Survival, superClass);

    function Survival() {
      this.victoryConditions = bind(this.victoryConditions, this);
      return Survival.__super__.constructor.apply(this, arguments);
    }

    Survival.prototype.waveFreq = 30;

    Survival.prototype.numComPoints = 12;

    Survival.prototype.start = function() {
      var key, p, ref, results;
      Survival.__super__.start.call(this);
      this.waveNum = 0;
      ref = this.players;
      results = [];
      for (key in ref) {
        p = ref[key];
        if (p && p.connected) {
          if (p.side === 'beta') {
            p.money = 1;
            results.push(p.moneyRatio = 0);
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Survival.prototype.endOfGame = function() {
      var id, key, object, p, ref, ref1, results;
      Survival.__super__.endOfGame.call(this);
      this.say("The survivors survived " + this.waveNum + " waves!");
      ref = this.things;
      for (id in ref) {
        object = ref[id];
        if (object.unit) {
          object.selfDestruct();
        }
      }
      ref1 = this.players;
      results = [];
      for (key in ref1) {
        p = ref1[key];
        if (p && p.connected) {
          if (p.moneyRatio === 0) {
            results.push(p.moneyRatio = 1);
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Survival.prototype.canStart = function() {
      return this.numInTeam("alpha") + this.numInTeam("beta") > 0;
    };

    Survival.prototype.simulate = function() {
      var betaCount, i, len, p, ref, results;
      Survival.__super__.simulate.call(this);
      if (this.state === 'running') {
        if ((this.step / 16) % this.waveFreq === 0 && this.step !== 0) {
          this.waveNum += 1;
          this.say("Spawning wave " + this.waveNum + "!");
          betaCount = this.players.filter(function(p) {
            return p.side === 'beta';
          }).length;
          ref = this.players;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            p = ref[i];
            if (p.side === "beta") {
              results.push(p.money = Math.round((2750 + Math.pow(1.1, this.waveNum) * 500) / betaCount));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      }
    };

    Survival.prototype.victoryConditions = function() {
      var capped, cappedArr, i, id, k, len, player, ref, ref1, stillThere, thing;
      if (this.state !== "running") {
        return;
      }
      capped = {};
      ref = this.things;
      for (id in ref) {
        thing = ref[id];
        if (thing.commandPoint) {
          capped[thing.side] = (capped[thing.side] || 0) + 1;
        }
      }
      cappedArr = (function() {
        var results;
        results = [];
        for (k in capped) {
          results.push(k);
        }
        return results;
      })();
      if (cappedArr.length === 0) {
        return;
      }
      if (cappedArr.length === 1 && cappedArr[0] === "beta") {
        this.winningSide = cappedArr[0];
      }
      if (this.winningSide) {
        this.endOfGame();
        return;
      }
      if (!this.local && !this.aiTestMode) {
        stillThere = false;
        ref1 = this.players;
        for (i = 0, len = ref1.length; i < len; i++) {
          player = ref1[i];
          if (!player.ai && player.connected && !player.afk && player.side !== "spectators") {
            stillThere = true;
          }
        }
        if (!stillThere) {
          this.say("Every one left. Ending game.");
          this.winningSide = false;
          this.endOfGame();
        }
      }
    };

    Survival.prototype.switchSide = function(player, side) {
      if (!player) {
        return;
      }
      if (player.kickTime > now() - 15000) {
        return;
      }
      if (this.local && !sim.galaxyStar && !sim.challenge) {
        player.side = side;
        return;
      }
      if (this.state !== "waiting") {
        return;
      }
      player.side = side;
      if (side === "spectators") {
        player.streek = 0;
      }
      return player.lastActiveTime = Date.now();
    };

    return Survival;

  })(window.Sim);

}).call(this);
;
  

