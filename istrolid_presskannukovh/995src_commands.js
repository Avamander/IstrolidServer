//require('./commands.js');
// Generated by CoffeeScript 1.12.7
(function () {
    var findRank, findChatPlayer, allowedSim, checkHost, checkRunning, defStats, helpMessage, parseStat,
        indexOf = [].indexOf || function (item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        };

    defStats = {
        parts: {},
        types: {}
    };

    window.diffStats = {
        sim: {}
    };

    allowedSim = ["mapScale", "numComPoints", "defaultMoney", "costLimit", "makeRocks", "awaitRestart", "tickTime", "moneyRatio", "unitLimit", "victoryGoal", "NxN", "enableAi", "check", "numFlags"];

    const current_teams = ["alpha", "beta"];

    findChatPlayer = function (name) {
        if (sim.chat.players) {
            let player = sim.chat.players[name];
            if (player) {
                return player;
            }
        }

        return {
            rank: 0
        };
    };

    findRank = function (name) {
        let chatPlayer = findChatPlayer(name);
        if (!chatPlayer) {
            return "?";
        }
        return Math.round(chatPlayer.rank || 0);
    };

    let find_best_teams = function (players) {
        players.sort(function (a, b) {
            return findRank(a.name) - findRank(b.name)
        });

        let combinations = permute(players);

        let best_combination = undefined;
        let best_combination_score = 256 * 256 * 256;
        let combination_score = 0;

        for (let i = 0; i < combinations.length; i++){
            let half_length = Math.floor(combinations[i].length / 2);

            let alpha_score = 0;
            for (let j = 0; j < half_length; j++){
                alpha_score += findRank(combinations[i][j].name);
            }

            let beta_score = 0;
            for (let j = half_length; j < combinations[i].length; j++){
                beta_score += findRank(combinations[i][j].name);
            }

            combination_score = Math.abs(alpha_score - beta_score);

            //console.log(combination_score, best_combination_score);
            if(combination_score < best_combination_score){
                best_combination = combinations[i];
                best_combination_score = combination_score;
            }
        }

        let result = [];
        result.push([]);
        result.push([]);

        for (let j = 0; j < Math.floor(best_combination.length / 2); j++){
            result[0].push(best_combination[j]);
        }

        for (let j = Math.floor(best_combination.length / 2); j < best_combination.length; j++){
            result[1].push(best_combination[j]);
        }
        return result;
    };

    let find_worst_teams = function (players) {
        players.sort(function (a, b) {
            return findRank(a.name) - findRank(b.name)
        });

        let combinations = permute(players);

        let best_combination = undefined;
        let best_combination_score = 0;
        let combination_score = 0;

        for (let i = 0; i < combinations.length; i++){
            let half_length = Math.floor(combinations[i].length / 2);

            let alpha_score = 0;
            for (let j = 0; j < half_length; j++){
                alpha_score += findRank(combinations[i][j].name);
            }

            let beta_score = 0;
            for (let j = half_length; j < combinations[i].length; j++){
                beta_score += findRank(combinations[i][j].name);
            }

            combination_score = Math.abs(alpha_score - beta_score);

            //console.log(combination_score, best_combination_score);
            if(combination_score > best_combination_score){
                best_combination = combinations[i];
                best_combination_score = combination_score;
            }
        }

        let result = [];
        result.push([]);
        result.push([]);

        for (let j = 0; j < Math.floor(best_combination.length / 2); j++){
            result[0].push(best_combination[j]);
        }

        for (let j = Math.floor(best_combination.length / 2); j < best_combination.length; j++){
            result[1].push(best_combination[j]);
        }
        return result;
    };

    let permute = function (input) {
        let r = [[input[0]]],
            t = [],
            s = [];

        if (input.length <= 1) return input;

        for (let i = 1, la = input.length; i < la; i++){
            for (let j = 0, lr = r.length; j < lr; j++){
                r[j].push(input[i]);
                t.push(r[j]);
                for(let k = 1, lrj = r[j].length; k < lrj; k++){
                    for (let l = 0; l < lrj; l++) s[l] = r[j][(k+l)%lrj];
                    t[t.length] = s;
                    s = [];
                }
            }
            r = t;
            t = [];
        }
        return r;
    };

    let select_k_from = function (from, k) {
        let i, j, combs, head, buff;

        if (k > set.length || k <= 0) {
            return [];
        } else if (k === set.length) {
            return [set];
        } else if (k === 1) {
            combs = [];
            for (i = 0; i < set.length; i++) {
                combs.push([set[i]]);
            }
            return combs;
        }

        combs = [];
        for (i = 0; i < set.length - k + 1; i++) {
            head = set.slice(i, i + 1);
            buff = select_k_from(set.slice(i + 1), k - 1);
            for (j = 0; j < buff.length; j++) {
                combs.push(head.concat(buff[j]));
            }
        }
        return combs;
    };

    let get_balance_index = function () {
        let alpha_players = sim.players.filter(function (filter_players) {
            return filter_players.connected &&
                filter_players.side === "alpha";
        });

        let beta_players = sim.players.filter(function (filter_players) {
            return filter_players.connected &&
                filter_players.side === "beta";
        });

        let beta_sum = 1;
        for (let i = 0; i < beta_players.length; i++) {
            beta_sum += findRank(beta_players[i].name);
        }

        let alpha_sum = 1;
        for (let i = 0; i < alpha_players.length; i++) {
            alpha_sum += findRank(alpha_players[i].name);
        }

        if (alpha_sum > beta_sum) {
            return (alpha_sum / beta_sum).toFixed(4);
        } else if (alpha_sum < beta_sum) {
            return (beta_sum / alpha_sum).toFixed(4);
        } else {
            return "perfect! :O";
        }
    };

    window.processCommand = function (player, cmds) {
        var _, aiBuildBar, debug, hostP, i, index, k, l, len, len1, n, name, p, picked, ref, current_players, ref2,
            ref3, ref4, repick, playing_players, playing_teams,
            results, results1, side, t, total, type, u, v;
        // noinspection FallThroughInSwitchStatementJS
        switch (cmds[0].toLowerCase()) {
            case "belence":
                if (checkRunning()) {
                    server.say("Game is running, not making things unfair!");
                    server.say("Current (im)balance index is " + get_balance_index());
                    break;
                }

                if (!(checkHost(player))) {
                    break;
                }

                playing_players = sim.players.filter(function (filter_players) {
                    return filter_players.connected &&
                        !filter_players.afk
                        && (filter_players.side === "alpha"
                            || filter_players.side === "beta");
                });

                playing_teams = find_worst_teams(playing_players);
                if (playing_teams === undefined){
                    console.log("Playing teams undefined", playing_teams);
                    break;
                }

                for (let team_index = 0; team_index < playing_teams.length; team_index++) {
                    for (let team_player of playing_teams[team_index]) {
                        team_player.side = current_teams[team_index]
                    }
                }

                server.say("Belenced");
                server.say("Current (im)balance index is " + get_balance_index());
                break;
            case "shuffle":
                if (checkRunning()) {
                    server.say("Game is running, not shuffling!");
                    server.say("Current (im)balance index is " + get_balance_index());
                    break;
                }

                if (!(checkHost(player))) {
                    break;
                }

                playing_players = sim.players.filter(function (filter_players) {
                    return filter_players.connected &&
                        !filter_players.afk
                        && (filter_players.side === "alpha"
                            || filter_players.side === "beta");
                });


                if (playing_players.length < 2) {
                    server.say("Not enough players!");
                    break;
                }

                playing_players = playing_players.sort(function (a, b) {
                    return Math.random() - 0.5;
                });


                for (let i = 0; i < playing_players.length; i++){
                    if(i % 2 === 0) {
                        playing_players[i].side = "alpha"
                    } else {
                        playing_players[i].side = "beta"
                    }
                }

                server.say("Shuffled");
                break;
            case "balance":
                if (checkRunning()) {
                    server.say("Game is running, not balancing!");
                    server.say("Current (im)balance index is " + get_balance_index());
                    break;
                }

                if (!(checkHost(player))) {
                    break;
                }

                playing_players = sim.players.filter(function (filter_players) {
                    return filter_players.connected &&
                        !filter_players.afk
                        && (filter_players.side === "alpha"
                            || filter_players.side === "beta");
                });

                if (playing_players.length < 2) {
                    server.say("Not enough players!");
                    break;
                }

                playing_teams = find_best_teams(playing_players);
                if (playing_teams === undefined){
                    console.log("Playing teams undefined", playing_teams);
                    break;
                }

                for (let team_index = 0; team_index < playing_teams.length; team_index++) {
                    for (let team_player of playing_teams[team_index]) {
                        team_player.side = current_teams[team_index]
                    }
                }

                server.say("Balanced!");
                server.say("Current (im)balance index is " + get_balance_index());
                break;
            case "gethost":
                if (!(checkHost(player))) {
                    break;
                }
                player.host = true;
                server.say("Host given");
                break;
            case "sethost":
                if (!(checkHost(player))) {
                    break;
                }
                player.host = false;

                let target_player = sim.players.filter(function (filter_players) {
                return filter_players.connected &&
                    (filter_players.side === "alpha" || filter_players.side === "beta") &&
                    filter_players.name === cmds[1];
                });

                if (target_player.length > 0){
                    target_player.host = true;
                } else {
                    server.say("No such player was found on either of the teams!");
                }
                break;
            case "m":
            case "mode":
                if (cmds.length < 2) {
                    server.say(helpMessage(cmds[0]));
                    break;
                }
                if (!(checkHost(player))) {
                    break;
                }

                if (checkRunning()) {
                    break;
                }

                type = (function () {
                    switch (cmds[1]) {
                        case "surv":
                        case "Surv":
                        case "survival":
                            return "Survival";
                        case "ffa":
                            return "FFA";
                        case "ctf":
                            return "CTF";
                        case "ttt":
                        case "TTT":
                            return "TicTacToe";
                        default:
                            return cmds[1];
                    }
                })();
                if (sim.validTypes[type] != null) {
                    return sim.configGame(player, {
                        type: type
                    });
                } else {
                    return server.say("unknown mode " + type);
                }
            case "start":
                if (checkRunning()) {
                    break;
                }

                if (!checkHost(player)) {
                    break;
                }

                return sim.startGame(player);
            case "j":
            case "join":
                if (cmds.length < 2) {
                    server.say(helpMessage(cmds[0]));
                    break;
                }
                if (checkRunning()) {
                    break;
                }
                if ((ref = cmds[1]) === "alpha" || ref === "beta" || ref === "spectators") {
                    return sim.switchSide(player, cmds[1]);
                } else {
                    return server.say("unknown team");
                }
            case "abs":
            case "abstain":
                if (!player.repick) {
                    server.say("You haven't voted!");
                    break;
                } else {
                    if (repick !== undefined && repick > 0) {
                        repick -= 1;
                        player.repick = false;
                        server.say("Abstained");
                        break;
                    } else {
                        server.say("There's nothing to abstain?");
                        break;
                    }
                }
            case "rpck":
            case "repick":
                player.repick = true;
                total = 0;
                repick = 0;
                current_players = sim.players;

                for (index = 0, len = current_players.length; index < len; index++) {
                    p = current_players[index];
                    if (!p.connected || p.afk || p.ai) {
                        continue;
                    }
                    total += 1;
                    if (p.repick) {
                        repick += 1;
                    }
                }

                if (sim.players.filter(function (f_player) {
                    return f_player.connected && !f_player.afk && (f_player.side === "alpha" || f_player.side === "beta");
                }).length < 2) {
                    server.say("Not enough players in the game");
                    break;
                }

                if (repick > total / 2) {
                    picked = false;
                    hostP = {};
                    ref2 = sim.players;
                    for (l = 0, len1 = ref2.length; l < len1; l++) {
                        p = ref2[l];
                        p.repick = false;
                        if (p.host) {
                            hostP = p;
                        }
                    }
                    while (!picked) {
                        p = sim.players[Math.floor(Math.random() * sim.players.length)];
                        if (p.host) {
                            continue;
                        }
                        if ((p.side === "alpha" || p.side === "beta") && !(p.ai || p.afk) && p.connected) {
                            p.host = true;
                            picked = true;
                        }
                    }
                    hostP.host = false;
                    return server.say("Host repicked");
                } else {
                    return server.say((Math.floor(total / 2) + 1 - repick) + " more votes needed");
                }
            case "addai":
                if (cmds.length < 3) {
                    server.say(helpMessage(cmds[0]));
                    break;
                }
                if (checkRunning()) {
                    break;
                }
                if (!(player.side === "alpha" || player.side === "beta" || player.name === "Avamander")) {
                    server.say("You need to be on a team");
                    break;
                }
                name = cmds[1];
                side = cmds[2].toLowerCase();
                if (side !== "alpha" && side !== "beta") {
                    server.say("Unknown team");
                    break;
                }
                aiBuildBar = ais.all[name];
                if (!aiBuildBar) {
                    server.say("Cannot find " + name + ", using your current fleet");
                    aiBuildBar = player.buildBar;
                }
                if (aiBuildBar) {
                    sim.addAi(player, name, side, aiBuildBar, true);
                    return server.say("Added " + name + " to " + side);
                }
                break;
            case "s":
            case "set":
                if (!checkHost(player)) {
                    break;
                }
                if (cmds.length < 4) {
                    server.say(helpMessage(cmds[0]));
                    break;
                }
                return changeStat(cmds[1], cmds[2], cmds[3]);
            case "changes":
                server.say("List of changes:");
                results = [];
                for (n in diffStats) {
                    p = diffStats[n];
                    results.push((function () {
                        let results1 = [];
                        for (k in p) {
                            v = p[k];
                            results1.push(server.say(n + "." + k + " = " + (typeof v === "function" ? v.name : v)));
                        }
                        return results1;
                    })());
                }
                return results;
            case "r":
            case "reset":
                if (!checkHost(player)) {
                    break;
                }
                resetStats();
                return server.say("Reset to default stats");
            case "export":
                sim.things = sim.things || {};
                ref3 = sim.things;
                for (_ in ref3) {
                    t = ref3[_];
                    if (t.owner === -1) {
                        t.hp = 0;
                    }
                }
                u = genStatUnit(diffStats);
                u.pos = [0, 0];
                u.rot = Math.PI;
                u.owner = -1;
                u.color = [255, 255, 0, 255];
                u.canCapture = false;
                sim.things[u.id] = u;
                return server.say("Stat changes exported, copy the unit with copy script to save it");
            case "import":
                if (!checkHost(player)) {
                    break;
                }
                if (cmds.length < 2) {
                    server.say(helpMessage(cmds[0]));
                    break;
                }
                resetStats();
                i = parseInt(cmds[1]);
                server.say("Loading stats from " + player.name + "'s slot: " + i);
                window.diffStats = statFromSpec(player.buildBar[i - 1]);
                return applyDiff(diffStats);
            case "fw":
            case "firework":
            case "fireworks":
                if (player.name !== "Avamander" || (!checkHost(player) && !checkRunning())) {
                    server.say("You need to be the host and the game must not be running to do that!");
                    break;
                }
                ref4 = sim.things;
                results1 = [];
                for (_ in ref4) {
                    t = ref4[_];
                    results1.push(t.hp = 0);
                }
                server.say("Poof!");
                return results1;
            case "debug":
                if (player.name !== "Avamander") {
                    server.say("only Avamander can do that");
                    break;
                }
                if (cmds.length > 1) {
                    debug = (function () {
                        switch (cmds[1].toLowerCase()) {
                            case "true":
                            case "on":
                            case "yes":
                                return true;
                            default:
                                return false;
                        }
                    })();
                } else {
                    debug = !DEBUG;
                }
                window.DEBUG = debug;
                return server.say("debug is now " + (debug ? "on" : "off"));
            case "end":
                if (!checkHost(player)) {
                    server.say("You would have to be the host for that!");
                    break;
                }
                return sim.endOfGame();
            case "restart":
                if (!(checkHost(player))) {
                    server.say("You would have to be the host for that!");
                    break;
                }
                server.say("Restarting server");
                return process.exit();
            case "h":
            case "help":
                return server.say(helpMessage(cmds[1]));
            default:
                return server.say(helpMessage());
        }
    };

    checkHost = function (p) {
        if (p != null ? p.host : void 0) {
            return true;
        }
        if ((p != null ? p.name : void 0) === "Avamander") {
            return true;
        }
        server.say("Only host can do that");
        return false;
    };

    checkRunning = function (p) {
        if (sim.state !== "running") {
            return false;
        }
        server.say("game already started");
        return true;
    };

    helpMessage = function (cmd) {
        var t;
        switch (cmd) {
            case "mode":
                return "!mode <mode> - switch gamemode. available modes: " + ((function () {
                    var results;
                    results = [];
                    for (t in sim.validTypes) {
                        results.push(t);
                    }
                    return results;
                })());
            case "start":
                return "!start - start the game";
            case "join":
                return "!join <side> - join a team";
            case "addai":
                return "!addai <name> <side> - add ai <name> to <side> team, use your current fleet if not found";
            case "repick":
                return "!repick - vote to repick the host";
            case "set":
                return "!set <part> <field> <value> - set a stat of a part";
            case "changes":
                return "!changes - list all the changes";
            case "reset":
                return "!reset - reset stats to defaule";
            case "export":
                return "!export - generate a ship that contains current stats";
            case "import":
                return "!import <slot> - import stats from unit in slot <slot>";
            case "end":
                return "!end - end the game";
            case "restart":
                return "!restart - restart the server";
            case "balance":
                return "!balance - balances the teams";
            case "belence":
                return "!belence - absolutely doesn't balance the teams";
            case "shuffle":
                return "!shuffle - shuffles the teams randomly";
            case "abstain":
                return "!abstain - undoes host repick vote";
            case "shuffle":
                return "!givehost <name> - gives host to the specified user currently playing";
            default:
                return "available commands: abstain givehost belence balance shuffle mode start join addai repick set changes reset export import end restart help";
        }
    };

    parseStat = function (t, str) {
        var v, value;
        if (typeof stat === t) {
            value = str;
        } else {
            value = (function () {
                var j, len, ref, results;
                switch (t) {
                    case "number":
                        return Number(str);
                    case "boolean":
                        return str.toLowerCase() === "true";
                    case "string":
                        return str;
                    case "object":
                        if (/(\d*.\d*,)*(\d*.\d*)/.test(str)) {
                            ref = str.split(",");
                            results = [];
                            for (j = 0, len = ref.length; j < len; j++) {
                                v = ref[j];
                                results.push(Number(v));
                            }
                            return results;
                        } else {
                            if (!quiet) {
                                server.say("Cannot parse " + str + " to " + t);
                            }
                            return null;
                        }
                        break;
                    case "function":
                        return types[str] || null;
                    default:
                        return null;
                }
            })();
        }
        return value;
    };

    window.genStatUnit = function (stats) {
        return new types.Unit({
            parts: [
                {
                    type: "HArmor2x2",
                    pos: [0, 0],
                    dir: 0
                }, {
                    type: "Battery1x1",
                    pos: [-10, -30],
                    dir: 0
                }, {
                    type: "Engine04",
                    pos: [10, -40],
                    dir: 0
                }
            ],
            aiRules: [
                [
                    "Code Block", JSON.stringify(stats, function (k, v) {
                    var name;
                    if (v === 2e308) {
                        return "Infinity";
                    } else if (typeof v === "function") {
                        name = v.name;
                        if (types.hasOwnProperty(name)) {
                            return name;
                        }
                    }
                    return v;
                })
                ]
            ]
        });
    };

    window.statFromSpec = function (spec) {
        var e, json, ref, ref1;
        if (spec == null) {
            return {
                sim: {}
            };
        }
        json = (ref = spec.aiRules) != null ? (ref1 = ref[0]) != null ? ref1[1] : void 0 : void 0;
        try {
            return JSON.parse(json, function (k, v) {
                if (v === "Infinity") {
                    return 2e308;
                } else if (types.hasOwnProperty(v)) {
                    return types[v];
                }
                return v;
            });
        } catch (error) {
            e = error;
        }
        return {
            sim: {}
        };
    };

    window.applyDiff = function (diff, quiet) {
        var k, n, p, results, v;
        if (quiet == null) {
            quiet = false;
        }
        results = [];
        for (n in diffStats) {
            p = diffStats[n];
            results.push((function () {
                var results1;
                results1 = [];
                for (k in p) {
                    v = p[k];
                    results1.push(changeStat(n, k, v, quiet));
                }
                return results1;
            })());
        }
        return results;
    };

    window.changeStat = function (type, field, stat, quiet) {
        var ns, part, ref, ref1, ref2, ref3, stats, t, universalButNo, value;
        if (quiet == null) {
            quiet = false;
        }
        if (!((type != null) && (field != null) && (stat != null))) {
            return;
        }
        if (type.toLowerCase() === "sim") {
            if (sim[field] == null) {
                if (field === "awaitRestart") {
                    sim.awaitRestart = false;
                } else {
                    if (!quiet) {
                        server.say("unknown field " + field);
                    }
                    return;
                }
            }
            if (indexOf.call(allowedSim, field) < 0) {
                if (!quiet) {
                    server.say("cannot change sim." + field);
                }
                return;
            }
            if (stat === "default") {
                sim[field] = sim.constructor.prototype[field];
                delete diffStats.sim[field];
                if (!quiet) {
                    server.say("sim." + field + " is now " + sim[field]);
                }
                return;
            }
            t = typeof sim[field];
            value = parseStat(t, stat);
            if ((value == null) || (t === "number" && isNaN(value))) {
                if (!quiet) {
                    server.say("invalid value " + stat);
                }
                return;
            }
            if (value != null) {
                sim[field] = value;
                diffStats.sim[field] = value;
                if (!quiet) {
                    server.say("sim." + field + " is now " + value);
                }
            }
            return;
        }
        part = {};
        if (parts[type]) {
            part = parts[type];
            ns = "parts";
        } else if (types[type]) {
            part = types[type];
            ns = "types";
        } else {
            if (!quiet) {
                server.say("cannot find " + type);
            }
            return;
        }
        if (!part) {
            if (!quiet) {
                server.say("unknown part " + type);
            }
            return;
        }
        universalButNo = {
            disable: false,
            hitsMissiles: false,
            missile: false
        };
        if (part.prototype[field] == null) {
            if (field in universalButNo) {
                part.prototype[field] = universalButNo[field];
            } else {
                if (!quiet) {
                    server.say("unknown field " + field);
                }
                return;
            }
        }
        if (stat === "default") {
            if (ns === "parts") {
                if ((ref = defStats.parts[type]) != null ? ref[field] : void 0) {
                    parts[type].prototype[field] = defStats.parts[type][field];
                }
                value = parts[type].prototype[field];
            } else if (ns === "types") {
                if ((ref1 = defStats.types[type]) != null ? ref1[field] : void 0) {
                    types[type].prototype[field] = defStats.types[type][field];
                }
                value = types[type].prototype[field];
            }
            if (sim.state === "running" && !quiet) {
                server.say("game is running, some units may keep the old stat");
            }
            if (!quiet) {
                server.say(type + "." + field + " is now " + (typeof value === "function" ? value.name : value));
            }
            if ((ref2 = diffStats[type]) != null) {
                delete ref2[field];
            }
            if (Object.keys(diffStats[type] || {}).length <= 0) {
                delete diffStats[type];
            }
            return;
        }
        t = typeof part.prototype[field];
        value = parseStat(t, stat);
        if ((value == null) || (t === "number" && isNaN(value))) {
            if (!quiet) {
                server.say("cannot parse " + stat + " to " + t);
            }
            return;
        }
        if (value != null) {
            if (!((ref3 = defStats[ns][type]) != null ? ref3[field] : void 0)) {
                stat = defStats[ns][type] || {};
                stat[field] = part.prototype[field];
                defStats[ns][type] = stat;
            }
            part.prototype[field] = value;
            stats = diffStats[type] || {};
            stats[field] = value;
            diffStats[type] = stats;
            if (sim.state === "running" && !quiet) {
                server.say("game is running, some units may keep the old stat");
            }
            if (!quiet) {
                return server.say(type + "." + field + " is now " + (t === "function" ? value.name : value));
            }
        }
    };

    window.resetStats = function () {
        var k, ref, ref1, ref2, stat, type, v;
        ref = defStats.parts;
        for (type in ref) {
            stat = ref[type];
            for (k in stat) {
                v = stat[k];
                parts[type].prototype[k] = v;
            }
        }
        ref1 = defStats.types;
        for (type in ref1) {
            stat = ref1[type];
            for (k in stat) {
                v = stat[k];
                types[type].prototype[k] = v;
            }
        }
        ref2 = diffStats.sim;
        for (k in ref2) {
            v = ref2[k];
            sim[k] = sim.constructor.prototype[k];
        }
        return window.diffStats = {
            sim: {}
        };
    };

    window.runText = function (text, color) {
        var j, muha, results, x, y;
        if (!sim.things) {
            return;
        }
        text = text.replace(/[^a-zA-Z0-9#.]/g, " ").slice(0, 25);
        muha = function (x, y, color) {
            var filename, j, len, letter, mu, ref, results;
            ref = text.toUpperCase();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
                letter = ref[j];
                if (letter === " ") {
                    x += 400;
                    continue;
                }
                mu = new types.Rock;
                filename = (function () {
                    switch (letter) {
                        case "#":
                            return "letterPound.png";
                        case ".":
                            return "letterDot.png";
                        default:
                            return "letter" + letter + ".png";
                    }
                })();
                mu.image = "parts/decals/" + filename;
                mu.color = color;
                mu.z = 10;
                mu["static"] = false;
                mu.size = [10, 10];
                mu.vel = [-350, 0];
                mu.pos = [x, y];
                mu.tick = function () {
                    if (this.pos[0] < -10000) {
                        return this.dead = true;
                    }
                };
                mu.move = function () {
                    return v2.add(this.pos, this.vel);
                };
                sim.things[mu.id] = mu;
                results.push(x += 400);
            }
            return results;
        };
        results = [];
        for (x = j = 0; j < 4000; x = j += 4000) {
            results.push((function () {
                var l, results1;
                results1 = [];
                for (y = l = -5000; l < 5000; y = l += 500) {
                    results1.push(muha(Math.random() * 10000 + 6000, y, color || [Math.random() * 255, Math.random() * 255, Math.random() * 255, 255]));
                }
                return results1;
            })());
        }
        return results;
    };

}).call(this);
