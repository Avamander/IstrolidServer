//require('../src/survival.js');
// Generated by CoffeeScript 1.12.7
(function () {
    var bind = function (fn, me) {
            return function () {
                return fn.apply(me, arguments);
            };
        },
        extend = function (child, parent) {
            for (let key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
            }

            function ctor() {
                this.constructor = child;
            }

            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        },
        hasProp = {}.hasOwnProperty;

    window.modes.Survival = (function (superClass) {
        extend(Survival, superClass);

        function Survival() {
            this.victoryConditions = bind(this.victoryConditions, this);
            return Survival.__super__.constructor.apply(this, arguments);
        }

        Survival.prototype.waveFreq = 30;

        Survival.prototype.numComPoints = 12;

        Survival.prototype.start = function () {
            let p, results;
            Survival.__super__.start.call(this);
            this.waveNum = 0;
            results = [];
            for (let key in this.players) {
                p = this.players[key];
                if (p && p.connected) {
                    if (p.side === 'beta') {
                        p.money = 1;
                        results.push(p.moneyRatio = 0);
                    } else {
                        results.push(void 0);
                    }
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };

        Survival.prototype.endOfGame = function () {
            let key, object, p, results;
            Survival.__super__.endOfGame.call(this);
            this.say("The survivors survived " + this.waveNum + " waves!");
            for (let id in this.things) {
                object = this.things[id];
                if (object.unit) {
                    object.selfDestruct();
                }
            }

            results = [];
            for (let key in this.players) {
                p = this.players[key];
                if (p && p.connected) {
                    if (p.moneyRatio === 0) {
                        results.push(p.moneyRatio = 1);
                    } else {
                        results.push(void 0);
                    }
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };

        Survival.prototype.canStart = function () {
            return this.numInTeam("alpha") + this.numInTeam("beta") > 0;
        };

        Survival.prototype.simulate = function () {
            let betaCount, i, len, p, ref, results;
            Survival.__super__.simulate.call(this);
            if (this.state === 'running') {
                if ((this.step / 16) % this.waveFreq === 0 && this.step !== 0) {
                    this.waveNum += 1;
                    this.say("Spawning wave " + this.waveNum + "!");
                    betaCount = this.players.filter(function (p) {
                        return p.side === 'beta';
                    }).length;
                    ref = this.players;
                    results = [];
                    for (i = 0, len = ref.length; i < len; i++) {
                        p = ref[i];
                        if (p.side === "beta") {
                            results.push(p.money = Math.round((2750 + Math.pow(1.1, this.waveNum) * 500) / betaCount));
                        } else {
                            results.push(void 0);
                        }
                    }
                    return results;
                }
            }
        };

        Survival.prototype.victoryConditions = function () {
            let capped, cappedArr, i, id, k, len, player, ref, ref1, stillThere, thing;
            if (this.state !== "running") {
                return;
            }
            capped = {};
            ref = this.things;
            for (id in ref) {
                thing = ref[id];
                if (thing.commandPoint) {
                    capped[thing.side] = (capped[thing.side] || 0) + 1;
                }
            }
            cappedArr = (function () {
                let results;
                results = [];
                for (k in capped) {
                    results.push(k);
                }
                return results;
            })();
            if (cappedArr.length === 0) {
                return;
            }
            if (cappedArr.length === 1 && cappedArr[0] === "beta") {
                this.winningSide = cappedArr[0];
            }
            if (this.winningSide) {
                this.endOfGame();
                return;
            }
            if (!this.local && !this.aiTestMode) {
                stillThere = false;
                ref1 = this.players;
                for (i = 0, len = ref1.length; i < len; i++) {
                    player = ref1[i];
                    if (!player.ai && player.connected && !player.afk && player.side !== "spectators") {
                        stillThere = true;
                    }
                }
                if (!stillThere) {
                    this.say("Every one left. Ending game.");
                    this.winningSide = false;
                    this.endOfGame();
                }
            }
        };

        Survival.prototype.switchSide = function (player, side) {
            if (!player) {
                return;
            }
            if (player.kickTime > now() - 15000) {
                return;
            }
            if (this.local && !sim.galaxyStar && !sim.challenge) {
                player.side = side;
                return;
            }
            if (this.state !== "waiting") {
                return;
            }
            player.side = side;
            if (side === "spectators") {
                player.streek = 0;
            }
            return player.lastActiveTime = Date.now();
        };

        return Survival;

    })(window.Sim);

}).call(this);
;
